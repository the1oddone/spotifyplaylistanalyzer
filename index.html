<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Playlist Growth Graph</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #121212; color: #ffffff; display: flex; flex-direction: column; align-items: center; padding: 2rem; margin: 0; }
        .container { background-color: #282828; padding: 2rem; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); width: 90%; max-width: 800px; text-align: center; }
        h1 { color: #1DB954; }
        button { background-color: #1DB954; color: white; border: none; padding: 12px 24px; font-size: 16px; font-weight: bold; border-radius: 500px; cursor: pointer; transition: background-color 0.2s; margin-top: 1rem; }
        button:hover { background-color: #1ED760; }
        button:disabled { background-color: #535353; cursor: not-allowed; }
        input[type="text"] { width: calc(100% - 24px); padding: 12px; margin: 1rem 0; border-radius: 5px; border: 1px solid #535353; background-color: #333; color: white; font-size: 16px; }
        #status { margin-top: 1.5rem; min-height: 24px; font-style: italic; color: #b3b3b3; }
        #chart-container { margin-top: 2rem; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Spotify Playlist Growth Analyzer</h1>
        <div id="login-section">
            <p>To begin, you need to authorize this page to read your playlist data.</p>
            <button id="login-btn">Authorize with Spotify</button>
        </div>
        <div id="app-section" class="hidden">
            <p>Authorization successful! âœ…</p>
            <label for="playlist-input">Paste your Spotify Playlist Link (URL) or URI:</label>
            <input type="text" id="playlist-input" placeholder="e.g., https://open.spotify.com/playlist/...">
            <button id="generate-btn">Generate Growth Graph</button>
        </div>
        <div id="status"></div>
        <div id="chart-container"><canvas id="growthChart"></canvas></div>
    </div>

    <script>
        // --- STEP 1: PASTE YOUR CLIENT ID HERE ---
        const CLIENT_ID = 'YOUR_CLIENT_ID_HERE'; 
        
        // This is your specific Redirect URI. Do not change this line.
        const REDIRECT_URI = 'https://the1oddone.github.io/spotifyplaylistanalyzer/index.html';
        const SCOPES = 'playlist-read-private playlist-read-collaborative';

        // --- NEW PKCE AUTHENTICATION CODE ---
        
        const loginBtn = document.getElementById('login-btn');
        const generateBtn = document.getElementById('generate-btn');
        const playlistInput = document.getElementById('playlist-input');
        const loginSection = document.getElementById('login-section');
        const appSection = document.getElementById('app-section');
        const statusEl = document.getElementById('status');
        const chartCanvas = document.getElementById('growthChart');
        let growthChart = null;

        window.onload = async () => {
            if (CLIENT_ID === 'YOUR_CLIENT_ID_HERE') {
                statusEl.innerHTML = `<strong>Error:</strong> You need to edit the HTML file and add your Spotify Client ID.`;
                loginBtn.disabled = true;
                return;
            }

            const params = new URLSearchParams(window.location.search);
            const code = params.get('code');

            if (code) {
                // We have a code, so we are coming back from Spotify
                // Now we need to exchange it for a token
                try {
                    const accessToken = await getAccessToken(code);
                    // Store token or use it directly
                    sessionStorage.setItem('spotify_access_token', accessToken);
                    showApp();
                    // Clean the URL
                    window.history.pushState({}, document.title, window.location.pathname);
                } catch (error) {
                    console.error('Error getting access token:', error);
                    alert('There was an error during authentication. Please try again.');
                }
            }
        };

        loginBtn.addEventListener('click', redirectToSpotifyAuthorize);

        async function redirectToSpotifyAuthorize() {
            const verifier = generateCodeVerifier(128);
            const challenge = await generateCodeChallenge(verifier);

            sessionStorage.setItem("verifier", verifier);

            const params = new URLSearchParams();
            params.append("client_id", CLIENT_ID);
            params.append("response_type", "code");
            params.append("redirect_uri", REDIRECT_URI);
            params.append("scope", SCOPES);
            params.append("code_challenge_method", "S256");
            params.append("code_challenge", challenge);

            document.location = `https://accounts.spotify.com/authorize?${params.toString()}`;
        }

        async function getAccessToken(code) {
            const verifier = sessionStorage.getItem("verifier");
            if (!verifier) {
                throw new Error("Code verifier not found in session storage.");
            }

            const params = new URLSearchParams();
            params.append("client_id", CLIENT_ID);
            params.append("grant_type", "authorization_code");
            params.append("code", code);
            params.append("redirect_uri", REDIRECT_URI);
            params.append("code_verifier", verifier);

            const result = await fetch("https://accounts.spotify.com/api/token", {
                method: "POST",
                headers: { "Content-Type": "application/x-www-form-urlencoded" },
                body: params
            });

            if (!result.ok) {
                 const errorText = await result.text();
                 throw new Error(`Failed to get token: ${errorText}`);
            }

            const { access_token } = await result.json();
            return access_token;
        }

        function generateCodeVerifier(length) {
            let text = '';
            let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
            for (let i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        }

        async function generateCodeChallenge(codeVerifier) {
            const data = new TextEncoder().encode(codeVerifier);
            const digest = await window.crypto.subtle.digest('SHA-256', data);
            return btoa(String.fromCharCode.apply(null, [...new Uint8Array(digest)]))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }
        
        const showApp = () => {
            loginSection.classList.add('hidden');
            appSection.classList.remove('hidden');
        };

        generateBtn.addEventListener('click', () => {
            const playlistValue = playlistInput.value;
            if (!playlistValue) {
                alert('Please paste a playlist link or URI.');
                return;
            }
            const playlistId = extractPlaylistId(playlistValue);
            if (!playlistId) {
                alert('Could not find a valid Playlist ID in the link. Please check it and try again.');
                return;
            }
            fetchAndDrawGraph(playlistId);
        });

        function extractPlaylistId(input) {
            try {
                const uriMatch = input.match(/spotify:playlist:([a-zA-Z0-9]+)/);
                if (uriMatch && uriMatch[1]) { return uriMatch[1]; }
                const url = new URL(input);
                if (url.hostname.includes('spotify.com') && url.pathname.includes('/playlist/')) {
                    const pathParts = url.pathname.split('/');
                    return pathParts[pathParts.length - 1];
                }
            } catch (error) {}
            return null;
        }

        async function fetchAllPlaylistTracks(playlistId) {
            const accessToken = sessionStorage.getItem('spotify_access_token');
            if (!accessToken) {
                alert('Authentication token is missing. Please re-authorize.');
                return;
            }
            let tracks = [];
            let nextUrl = `https://api.spotify.com/v1/playlists/${playlistId}/tracks?fields=items(added_at,track(name)),next,total`;
            let page = 1;
            let total = 0;
            while (nextUrl) {
                const response = await fetch(nextUrl, { headers: { 'Authorization': `Bearer ${accessToken}` } });
                if (!response.ok) {
                    if (response.status === 401) throw new Error("Authorization token expired. Please re-authorize by refreshing the page.");
                    if (response.status === 404) throw new Error("Playlist not found. Check the link or make sure it's not private.");
                    throw new Error(`API Error: ${response.statusText}`);
                }
                const data = await response.json();
                if (page === 1) total = data.total;
                statusEl.textContent = `Fetching tracks... Page ${page} (found ${tracks.length + data.items.length} of ${total})`;
                tracks = tracks.concat(data.items.filter(item => item.track));
                nextUrl = data.next;
                page++;
            }
            return tracks;
        }

        async function fetchAndDrawGraph(playlistId) {
            generateBtn.disabled = true;
            statusEl.textContent = 'Starting analysis...';
            if (growthChart) { growthChart.destroy(); }
            try {
                const allTracks = await fetchAllPlaylistTracks(playlistId);
                statusEl.textContent = 'Processing data...';
                allTracks.sort((a, b) => new Date(a.added_at) - new Date(b.added_at));
                const chartData = allTracks.map((item, index) => ({ x: new Date(item.added_at), y: index + 1 }));
                if (chartData.length > 0) {
                    const firstDate = chartData[0].x;
                    chartData.unshift({ x: new Date(firstDate.getTime() - 1000), y: 0 });
                }
                renderChart(chartData);
                statusEl.innerHTML = `<strong>Analysis Complete!</strong> Found ${allTracks.length} tracks.`;
            } catch (error) {
                statusEl.innerHTML = `<strong>Error:</strong> ${error.message}`;
                alert(`An error occurred: ${error.message}`);
            } finally {
                generateBtn.disabled = false;
            }
        }
        function renderChart(data) {
            const ctx = chartCanvas.getContext('2d');
            growthChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Total Song Count', data: data, borderColor: '#1DB954', backgroundColor: 'rgba(29, 185, 84, 0.2)', fill: true, tension: 0.1, pointRadius: 0
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: true,
                    plugins: { title: { display: true, text: 'Playlist Growth Over Time', color: '#ffffff', font: { size: 18 } }, legend: { labels: { color: '#ffffff' } } },
                    scales: {
                        x: { type: 'time', time: { unit: 'month', tooltipFormat: 'MMM d, yyyy' }, title: { display: true, text: 'Date Added', color: '#b3b3b3' }, ticks: { color: '#b3b3b3' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } },
                        y: { beginAtZero: true, title: { display: true, text: 'Number of Songs', color: '#b3b3b3' }, ticks: { color: '#b3b3b3' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }
                    }
                }
            });
        }
    </script>
</body>
</html>
